---
phase: 01-parser-foundation
plan: "01"
type: execute
wave: 2
depends_on:
  - "01-02"
files_modified:
  - internal/parser/pi.go
autonomous: true
requirements:
  - PRSR-01
  - PRSR-02
  - PRSR-03
  - PRSR-04
  - PRSR-05
  - PRSR-06
  - PRSR-07
  - PRSR-08
  - PRSR-09
  - PRSR-10
must_haves:
  truths:
    - "ParsePiSession returns a ParsedSession with Agent=AgentPi, correct ID, project, timestamps, and message counts"
    - "Assistant messages with toolCall blocks have HasToolUse=true and populated ToolCalls using toolCall/arguments (not tool_use/input)"
    - "Thinking blocks (including redacted) set HasThinking=true on the containing assistant message"
    - "Tool result entries (role=toolResult) are parsed as ParsedMessage with ToolResults populated"
    - "compaction entries produce a synthetic user message with FTS-indexable content"
    - "model_change entries produce a meta message with content 'Model changed to {provider}/{modelId}'"
    - "V1 sessions (no id field anywhere) use filename basename as session ID"
    - "branchedFrom absolute path is stored as basename-without-extension in ParentSessionID"
    - "Malformed JSON lines and unrecognized entry types are skipped silently"
  artifacts:
    - path: "internal/parser/pi.go"
      provides: "ParsePiSession function"
      exports: ["ParsePiSession"]
      min_lines: 100
  key_links:
    - from: "internal/parser/pi.go"
      to: "internal/parser/types.go"
      via: "AgentPi constant"
      pattern: "AgentPi"
    - from: "internal/parser/pi.go"
      to: "newLineReader"
      via: "JSONL line buffering"
      pattern: "newLineReader"
    - from: "internal/parser/pi.go"
      to: "NormalizeToolCategory"
      via: "tool call category normalization"
      pattern: "NormalizeToolCategory"
---

<objective>
Implement `internal/parser/pi.go` — a new Go parser for pi-agent JSONL session files that populates `ParsedSession` and `[]ParsedMessage` with full parity to the Claude parser.

Purpose: Pi sessions cannot be ingested until this parser exists. It is the root dependency for all subsequent phase work (sync wiring, config, frontend).
Output: `internal/parser/pi.go` with `ParsePiSession(path, project, machine string) (*ParsedSession, []ParsedMessage, error)`.
</objective>

<execution_context>
@/Users/carze/.claude/get-shit-done/workflows/execute-plan.md
@/Users/carze/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-parser-foundation/01-RESEARCH.md
@.planning/phases/01-parser-foundation/01-CONTEXT.md

<!-- Prior plan context needed: AgentPi constant from 01-02 -->
@.planning/phases/01-parser-foundation/01-02-SUMMARY.md

<interfaces>
<!-- All types and helpers the executor needs. No codebase exploration required. -->

From internal/parser/types.go:
```go
type AgentType string
const (
    AgentClaude   AgentType = "claude"
    AgentCodex    AgentType = "codex"
    AgentCopilot  AgentType = "copilot"
    AgentGemini   AgentType = "gemini"
    AgentOpenCode AgentType = "opencode"
    AgentCursor   AgentType = "cursor"
    AgentPi       AgentType = "pi"   // added by 01-02
)

type RoleType string
const (
    RoleUser      RoleType = "user"
    RoleAssistant RoleType = "assistant"
)

type FileInfo struct {
    Path  string
    Size  int64
    Mtime int64
    Hash  string
}

type ParsedSession struct {
    ID               string
    Project          string
    Machine          string
    Agent            AgentType
    ParentSessionID  string
    RelationshipType RelationshipType
    FirstMessage     string
    StartedAt        time.Time
    EndedAt          time.Time
    MessageCount     int
    UserMessageCount int
    File             FileInfo
}

type ParsedToolCall struct {
    ToolUseID         string
    ToolName          string
    Category          string
    InputJSON         string
    SkillName         string
    SubagentSessionID string
}

type ParsedToolResult struct {
    ToolUseID     string
    ContentLength int
}

type ParsedMessage struct {
    Ordinal       int
    Role          RoleType
    Content       string
    Timestamp     time.Time
    HasThinking   bool
    HasToolUse    bool
    ContentLength int
    ToolCalls     []ParsedToolCall
    ToolResults   []ParsedToolResult
}
```

From internal/parser/linereader.go:
```go
// newLineReader creates a buffered line reader that handles lines up to maxLineSize.
// initialScanBufSize and maxLineSize constants are defined in claude.go.
func newLineReader(r io.Reader, maxSize int) *bufio.Scanner
```

From internal/parser/timestamp.go:
```go
// parseTimestamp parses ISO 8601 / RFC3339 strings.
// Returns zero time.Time for empty or unrecognized input.
// Does NOT handle Unix millisecond integers — use time.UnixMilli(n).UTC() for those.
func parseTimestamp(s string) time.Time
```

From internal/parser/taxonomy.go:
```go
// NormalizeToolCategory maps raw tool names to categories.
// Pi tools: "find" -> "Read", "grep" -> "Grep" (already in Gemini section)
func NormalizeToolCategory(rawName string) string
```

From internal/parser/project.go:
```go
// ExtractProjectFromCwd extracts a human-readable project name from a cwd path.
func ExtractProjectFromCwd(cwd string) string
```

From internal/parser/claude.go (constants to reuse):
```go
const (
    initialScanBufSize = 64 * 1024      // 64 KB initial buffer
    maxLineSize        = 64 * 1024 * 1024  // 64 MB max line
)
```

From internal/parser/content.go:
```go
// DO NOT reuse ExtractTextContent for pi — it looks for "tool_use" blocks, not "toolCall".
// Pi uses different block type names: toolCall/arguments instead of tool_use/input.
// Write a dedicated extractPiContent helper instead.
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ParsePiSession in internal/parser/pi.go</name>
  <files>internal/parser/pi.go</files>
  <action>
    Create `internal/parser/pi.go` in package `parser`. Implement `ParsePiSession(path, project, machine string) (*ParsedSession, []ParsedMessage, error)` following the single-pass Gemini-style pattern (not Claude's two-pass DAG).

    **File structure:**
    ```
    package parser
    imports: fmt, os, path/filepath, strings, time, github.com/tidwall/gjson
    ```

    **Function signature:**
    ```go
    func ParsePiSession(path, project, machine string) (*ParsedSession, []ParsedMessage, error)
    ```

    **Implementation requirements (all locked decisions from CONTEXT.md apply):**

    1. **File open**: Use `os.Stat` + `os.Open` pattern (same as Gemini). Defer close.

    2. **Line reader**: Use `newLineReader(f, maxLineSize)` — do not implement a custom scanner.

    3. **Session header (first non-empty line)**:
       - Expect `type=session`; if not found, return error: `fmt.Errorf("not a pi session: missing session header in %s", path)`
       - Extract: `id` (string), `cwd` (string), `timestamp` (ISO 8601)
       - `branchedFrom`: if non-empty, extract `filepath.Base(branchedFrom)` then `strings.TrimSuffix(base, filepath.Ext(base))` → store as `parentSessionID`
       - V1 detection: track whether ANY line in the file contains an `id` field. If header `id` is empty, tentatively set `isV1 = true`. If any message entry later has an `id` field, set `isV1 = false`. After the full pass, if `isV1`, derive session ID from `strings.TrimSuffix(filepath.Base(path), ".jsonl")`.

    4. **Main loop** — entry type dispatch:
       ```
       case "message": dispatch on message.role
           "user"       → parseUserMessage
           "assistant"  → parseAssistantMessage
           "toolResult" → parseToolResultMessage
           default      → skip silently
       case "model_change" → synthetic meta message
       case "compaction"   → synthetic user message
       default             → skip silently (e.g., thinking_level_change)
       ```

    5. **User messages** (role="user"):
       - `message.content` can be a plain string OR a `[{"type":"text","text":"..."}]` array. Handle both.
       - Plain string: `gjson.Get(line, "message.content").Type == gjson.String`
       - Array: iterate blocks, collect `type=text` blocks only (skip image blocks).
       - Timestamp: try `parseTimestamp(gjson.Get(line, "timestamp").Str)` first; if zero, fall back to `time.UnixMilli(gjson.Get(line, "message.timestamp").Int()).UTC()`.
       - Set `FirstMessage` from the first non-empty user message content (truncated to 300 chars, newlines replaced with spaces).

    6. **Assistant messages** (role="assistant"):
       - Iterate `message.content` blocks via `gjson.Get(line, "message.content").ForEach`.
       - Block types:
         - `text`: append to content parts
         - `thinking`: set `hasThinking=true` REGARDLESS of whether `thinking` field is empty (handles redacted thinking — the block type presence is sufficient)
         - `toolCall`: set `hasToolUse=true`; extract `id`, `name`, `arguments` (Raw JSON); create `ParsedToolCall{ToolUseID: id, ToolName: name, Category: NormalizeToolCategory(name), InputJSON: argumentsRaw}`
         - All other block types: skip silently
       - `ContentLength` = total character length of all text parts
       - Timestamp: same two-source fallback as user messages.

    7. **Tool result messages** (role="toolResult"):
       - `toolUseID` = `gjson.Get(line, "message.toolCallId").Str`
       - Content length: sum `len(block.Get("text").Str)` for each block in `message.content`
       - Role: use `RoleUser` (matches Claude pattern for tool results)
       - Append `ParsedMessage{Role: RoleUser, ToolResults: []ParsedToolResult{{ToolUseID: toolUseID, ContentLength: contentLen}}, Timestamp: ts, Ordinal: ordinal}`

    8. **model_change entries**:
       - Content: `fmt.Sprintf("Model changed to %s/%s", provider, modelId)` where provider = `gjson.Get(line, "provider").Str` and modelId = `gjson.Get(line, "modelId").Str`
       - Role: `RoleUser`
       - Timestamp from `gjson.Get(line, "timestamp").Str`

    9. **compaction entries**:
       - `summary` = `gjson.Get(line, "summary").Str`
       - If summary is empty: use `"[session compacted]"` as fallback
       - Role: `RoleUser`, content = summary
       - Timestamp from `gjson.Get(line, "timestamp").Str`

    10. **Error handling**: Any JSON line that fails `gjson.Valid` or produces an empty `type` field: skip silently. No log output from the parser.

    11. **Session assembly at end**:
        - `StartedAt`: earliest non-zero message timestamp (or header timestamp as fallback)
        - `EndedAt`: latest non-zero message timestamp
        - `MessageCount`: `len(messages)`
        - `UserMessageCount`: count of messages where `Role == RoleUser && Content != ""`
        - `File`: `FileInfo{Path: path, Size: info.Size(), Mtime: info.ModTime().UnixNano()}`
        - Session ID: V2 = header `id` field; V1 = filename basename without extension

    **Do not** call `ExtractTextContent` — pi uses `toolCall`/`arguments`, not `tool_use`/`input`.
  </action>
  <verify>
    <automated>cd /Users/carze/Documents/personal/misc/agentsview && CGO_ENABLED=1 go build -tags fts5 ./internal/parser/...</automated>
  </verify>
  <done>
    - `internal/parser/pi.go` exists and compiles with `CGO_ENABLED=1 -tags fts5`
    - `ParsePiSession` is exported and has the correct signature
    - `go vet ./internal/parser/...` passes with no errors
  </done>
</task>

</tasks>

<verification>
After implementation:

```bash
cd /Users/carze/Documents/personal/misc/agentsview && CGO_ENABLED=1 go build -tags fts5 ./internal/parser/... && go vet ./internal/parser/...
```

Expected: clean build and vet with no errors.
</verification>

<success_criteria>
- `internal/parser/pi.go` compiles cleanly
- `ParsePiSession` handles: V2 sessions, V1 sessions (id-less), user messages (string + array content), assistant messages (text + thinking + toolCall blocks), tool result entries, model_change, compaction, branchedFrom extraction, silent skip of malformed JSON and unknown entry types
- All locked decisions from CONTEXT.md are implemented exactly as specified
- No new external dependencies added (gjson, filepath, strings, fmt, os, time are all already available)
</success_criteria>

<output>
After completion, create `.planning/phases/01-parser-foundation/01-01-SUMMARY.md`
</output>
