---
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/utils/content-parser.ts
  - frontend/src/lib/utils/content-parser.test.ts
autonomous: true
must_haves:
  - Lowercase pi tool names (bash, read, write, edit, grep, glob, find) resolve to their canonical display labels in TOOL_ALIASES
  - Pi bash tool calls show command preview ($ command) in collapsed header — both enrichSegments code paths handle lowercase "bash"
  - Pi read tool calls show file path preview in collapsed header via enrichSegments content expansion
  - All existing content-parser tests continue to pass
  - New tests cover: lowercase alias resolution, bash expansion for lowercase "bash", read path expansion
---

# Plan 05-01: Content Parser — Lowercase Aliases, Bash Expansion, Read Path Preview

## Objective

Extend `content-parser.ts` so that pi's lowercase tool names (`bash`, `read`, `write`, `edit`, `grep`, `glob`, `find`) display with canonical labels, pi `bash` tool calls show a command preview in the collapsed header, and pi `read`/`read_file` tool calls show their file path in the collapsed header.

## Context

Pi uses lowercase OpenCode-style tool names. After Phase 4, `TOOL_ALIASES` maps `run_command`, `str_replace`, `create_file`, `read_file` but NOT the bare lowercase names `bash`, `read`, `write`, `edit`, `grep`, `glob`, `find`. This means:

1. A pi `bash` tool call gets label `"bash"` (lowercase) instead of `"Bash"` — visually inconsistent.
2. The Bash expansion check in `enrichSegments` matches `tc.tool_name === "Bash"` — it misses `"bash"`, so pi bash calls show no command preview.
3. Pi `read` tool calls get `content = ""` — no preview in the collapsed header.

Two separate code paths in `enrichSegments` handle tool calls:
- **Text-marker pairing loop** (~line 362): pairs text-marker tool segments with structured tool_calls. The Bash expansion is here (tc.tool_name === "Bash" || tc.tool_name === "run_command").
- **`!hasTextBasedTools` append loop** (~line 401): appends structured JSON tool calls as new segments when no text markers exist (pi/omp style). The same Bash expansion runs here.

Both paths need updating. Extracting a `isBashTool(name)` helper avoids duplicating the condition.

## Task 1 — Add Lowercase Pi Tool Aliases and `isBashTool`/`isReadTool` Helpers

**Type:** edit
**Files:**
- `frontend/src/lib/utils/content-parser.ts`

**Action:**

1. Add lowercase pi/OpenCode tool names to `TOOL_ALIASES` immediately after the existing pi tool names (after `read_file: "Read"`):

```typescript
  // Lowercase pi/OpenCode bare tool names
  bash: "Bash",
  read: "Read",
  write: "Write",
  edit: "Edit",
  grep: "Grep",
  glob: "Glob",
  find: "Read",
```

2. Add two helper functions immediately after the `TOOL_ALIASES` constant and before `TOOL_RE`:

```typescript
function isBashTool(name: string): boolean {
  return name === "Bash" || name === "bash" || name === "run_command";
}

function isReadTool(name: string): boolean {
  return name === "Read" || name === "read" || name === "read_file";
}
```

**Verify:**

After editing, confirm:
- `TOOL_ALIASES` now includes `bash: "Bash"`, `read: "Read"`, `write: "Write"`, `edit: "Edit"`, `grep: "Grep"`, `glob: "Glob"`, `find: "Read"`.
- `isBashTool` and `isReadTool` functions are defined before `TOOL_RE`.
- No TypeScript errors: `cd frontend && npx tsc --noEmit 2>&1 | head -20`

**Done when:** The file compiles cleanly and `TOOL_ALIASES` contains all seven new entries.

## Task 2 — Update `enrichSegments` to Use Helpers and Add Read Path Expansion

**Type:** edit
**Files:**
- `frontend/src/lib/utils/content-parser.ts`

**Action:**

Update `enrichSegments` in two places to use the `isBashTool` helper and add Read path expansion in the `!hasTextBasedTools` append loop.

**Change 1 — Text-marker pairing loop** (inside the `if (seg.type === "tool" && tcIdx < toolCalls.length)` branch):

Replace:
```typescript
      if ((tc.tool_name === "Bash" || tc.tool_name === "run_command") && tc.input_json) {
```
With:
```typescript
      if (isBashTool(tc.tool_name) && tc.input_json) {
```

**Change 2 — `!hasTextBasedTools` append loop**:

Replace the entire Bash expansion block:
```typescript
      let content = "";
      if ((tc.tool_name === "Bash" || tc.tool_name === "run_command") && tc.input_json) {
        try {
          const input = JSON.parse(tc.input_json);
          const fullCmd = input.command;
          if (fullCmd) {
            content = `$ ${fullCmd}`;
          }
        } catch {
          /* leave empty, ToolBlock will use fallbackContent */
        }
      }
```

With:
```typescript
      let content = "";
      if (isBashTool(tc.tool_name) && tc.input_json) {
        try {
          const input = JSON.parse(tc.input_json);
          const fullCmd = input.command;
          if (fullCmd) {
            content = `$ ${fullCmd}`;
          }
        } catch {
          /* leave empty, ToolBlock will use fallbackContent */
        }
      } else if (isReadTool(tc.tool_name) && tc.input_json) {
        try {
          const input = JSON.parse(tc.input_json);
          const filePath = input.path ?? input.file_path;
          if (filePath) {
            content = String(filePath);
          }
        } catch {
          /* leave empty */
        }
      }
```

**Verify:**

- `cd frontend && npx tsc --noEmit 2>&1 | head -20` — no errors
- Both Bash expansion `if` conditions now call `isBashTool(tc.tool_name)`.
- The `!hasTextBasedTools` append loop has the new `else if (isReadTool(...))` branch.

**Done when:** File compiles cleanly and both enrichSegments code paths use the helpers.

## Task 3 — Add Tests for Aliases, Bash Expansion, and Read Path Preview

**Type:** edit
**Files:**
- `frontend/src/lib/utils/content-parser.test.ts`

**Action:**

Add two new describe blocks at the end of the file (after the existing `enrichSegments - pi tool aliasing` describe block).

**Block 1 — Lowercase pi native tool aliases:**

```typescript
describe("enrichSegments - pi lowercase native tool aliases", () => {
  function makeStructuredSegments(toolCalls: ToolCall[]): ReturnType<typeof enrichSegments> {
    const segments = parseContent("Working on files.");
    return enrichSegments(segments, toolCalls);
  }

  it("aliases lowercase bash to Bash label", () => {
    const tc: ToolCall = {
      tool_name: "bash",
      category: "Bash",
      input_json: '{"command":"ls -la","agent__intent":"List files"}',
    };
    const result = makeStructuredSegments([tc]);
    const toolSegs = result.filter((s) => s.type === "tool");
    expect(toolSegs).toHaveLength(1);
    expect(toolSegs[0]!.label).toBe("Bash");
  });

  it("aliases lowercase read to Read label", () => {
    const tc: ToolCall = {
      tool_name: "read",
      category: "Read",
      input_json: '{"path":"/src/app.ts"}',
    };
    const result = makeStructuredSegments([tc]);
    const toolSegs = result.filter((s) => s.type === "tool");
    expect(toolSegs).toHaveLength(1);
    expect(toolSegs[0]!.label).toBe("Read");
  });

  it("aliases lowercase write to Write label", () => {
    const tc: ToolCall = {
      tool_name: "write",
      category: "Write",
      input_json: '{"path":"/src/new.ts","content":"x"}',
    };
    const result = makeStructuredSegments([tc]);
    const toolSegs = result.filter((s) => s.type === "tool");
    expect(toolSegs).toHaveLength(1);
    expect(toolSegs[0]!.label).toBe("Write");
  });

  it("aliases lowercase edit to Edit label", () => {
    const tc: ToolCall = {
      tool_name: "edit",
      category: "Edit",
      input_json: '{"path":"/src/app.ts","edits":[]}',
    };
    const result = makeStructuredSegments([tc]);
    const toolSegs = result.filter((s) => s.type === "tool");
    expect(toolSegs).toHaveLength(1);
    expect(toolSegs[0]!.label).toBe("Edit");
  });

  it("aliases lowercase grep to Grep label", () => {
    const tc: ToolCall = {
      tool_name: "grep",
      category: "Grep",
      input_json: '{"pattern":"TODO","path":"/src"}',
    };
    const result = makeStructuredSegments([tc]);
    const toolSegs = result.filter((s) => s.type === "tool");
    expect(toolSegs).toHaveLength(1);
    expect(toolSegs[0]!.label).toBe("Grep");
  });

  it("aliases lowercase glob to Glob label", () => {
    const tc: ToolCall = {
      tool_name: "glob",
      category: "Glob",
      input_json: '{"pattern":"**/*.ts"}',
    };
    const result = makeStructuredSegments([tc]);
    const toolSegs = result.filter((s) => s.type === "tool");
    expect(toolSegs).toHaveLength(1);
    expect(toolSegs[0]!.label).toBe("Glob");
  });

  it("aliases find to Read label", () => {
    const tc: ToolCall = {
      tool_name: "find",
      category: "Read",
      input_json: '{"pattern":"*.go"}',
    };
    const result = makeStructuredSegments([tc]);
    const toolSegs = result.filter((s) => s.type === "tool");
    expect(toolSegs).toHaveLength(1);
    expect(toolSegs[0]!.label).toBe("Read");
  });

  it("expands lowercase bash command to $ format", () => {
    const segments = parseContent("");
    const tc: ToolCall = {
      tool_name: "bash",
      category: "Bash",
      input_json: '{"command":"npm test","agent__intent":"Run tests"}',
    };
    const result = enrichSegments(segments, [tc]);
    expect(result[0]!.content).toBe("$ npm test");
  });

  it("expands multi-line lowercase bash to $ format", () => {
    const segments = parseContent("");
    const tc: ToolCall = {
      tool_name: "bash",
      category: "Bash",
      input_json: JSON.stringify({ command: "git commit -m \"$(cat <<'EOF')\nMessage\nEOF\n)\"" }),
    };
    const result = enrichSegments(segments, [tc]);
    expect(result[0]!.content).toContain("$ git commit");
  });
});
```

**Block 2 — Read path preview expansion:**

```typescript
describe("enrichSegments - Read path preview", () => {
  it("sets content to file path for lowercase read tool", () => {
    const segments = parseContent("");
    const tc: ToolCall = {
      tool_name: "read",
      category: "Read",
      input_json: '{"path":"/src/auth.go","agent__intent":"Reading auth module"}',
    };
    const result = enrichSegments(segments, [tc]);
    expect(result[0]!.content).toBe("/src/auth.go");
  });

  it("sets content to file path for read_file tool", () => {
    const segments = parseContent("");
    const tc: ToolCall = {
      tool_name: "read_file",
      category: "Read",
      input_json: '{"path":"/src/main.go"}',
    };
    const result = enrichSegments(segments, [tc]);
    expect(result[0]!.content).toBe("/src/main.go");
  });

  it("prefers path over file_path for read tool (pi field name)", () => {
    const segments = parseContent("");
    const tc: ToolCall = {
      tool_name: "read",
      category: "Read",
      input_json: '{"path":"/src/app.ts","file_path":"/src/other.ts"}',
    };
    const result = enrichSegments(segments, [tc]);
    expect(result[0]!.content).toBe("/src/app.ts");
  });

  it("leaves content empty for read tool with no path", () => {
    const segments = parseContent("");
    const tc: ToolCall = {
      tool_name: "read",
      category: "Read",
      input_json: '{"agent__intent":"reading something"}',
    };
    const result = enrichSegments(segments, [tc]);
    expect(result[0]!.content).toBe("");
  });
});
```

**Verify:**

Run the full test suite:
```bash
cd /Users/carze/Documents/personal/misc/agentsview/frontend && npm test -- --run src/lib/utils/content-parser.test.ts 2>&1 | tail -30
```

All tests must pass. Confirm new tests appear and pass.

**Done when:** All tests pass including the two new describe blocks.

## Verification

```bash
# TypeScript compilation check
cd /Users/carze/Documents/personal/misc/agentsview/frontend && npx tsc --noEmit 2>&1 | head -20

# Run content-parser tests
cd /Users/carze/Documents/personal/misc/agentsview/frontend && npm test -- --run src/lib/utils/content-parser.test.ts 2>&1 | tail -40
```

Expected: zero TypeScript errors; all tests pass including the new alias and path preview tests.

## Success Criteria

- [ ] `TOOL_ALIASES` contains `bash`, `read`, `write`, `edit`, `grep`, `glob`, `find` entries
- [ ] `isBashTool` and `isReadTool` helper functions exist in `content-parser.ts`
- [ ] Text-marker pairing loop uses `isBashTool(tc.tool_name)`
- [ ] `!hasTextBasedTools` append loop uses `isBashTool(tc.tool_name)` and adds `isReadTool` branch
- [ ] All existing tests pass
- [ ] New alias tests pass (7 tools aliased)
- [ ] New bash expansion test passes (lowercase `bash` gets `$ command` content)
- [ ] New read path preview tests pass

## Output

Modified files:
- `frontend/src/lib/utils/content-parser.ts` — aliases, helpers, enrichSegments changes
- `frontend/src/lib/utils/content-parser.test.ts` — new test describe blocks
